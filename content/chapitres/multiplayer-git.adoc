[{invert}]
= Git √† plusieurs

== Limites de travailler seul

* Capacit√© finie de travail
* Victime de propres biais
* On ne sait pas tout

== !

image:solo.gif[width="500"]

== Travailler en √©quipe ? Une si bonne id√©e ?

* ... Mais il faut communiquer ?
* ... Mais tout le monde n'a pas les m√™mes comp√©tences ?
* ... Mais tout le monde y code pas pareil ?

== !

Collaborer c'est pas √©vident, mais il existe des outils et des m√©thodes pour vous aider.

[.small]
Cela reste des outils, √ßa ne r√©sous pas tout non plus.

== Git multijoueur

* Git permet de collaborer assez ais√©ment
* Chaque d√©veloppeur cr√©e et publie des commits...
* ... et rapatrie ceux de de ses camarades !
* C'est un outil tr√®s flexible... chacun peut faire ce qu'il lui semble bon !

== ... et (souvent) √ßa finit comme √ßa !

image:bloing.jpeg[]

== Un Example de Git Flow

(Attachez vous aux id√©es g√©n√©rales... les d√©tails varient d'un projet √† l'autre!)

== Gestion des branches

* Les "versions" du logiciel sont maintenues sur des branches principales (main, staging)

* Ces branches refl√®tent l'√©tat du logiciel
** **main**: version actuelle en production
** **staging**: prochaine version

== !

image:gitmulti1.svg[]

== Gestion des branches

* Chaque groupe de travail (d√©veloppeur, bin√¥me...)
** Cr√©e une branche de travail √† partir de la branche staging
** Une branche de travail correspond √† *une chose √† la fois*
** Pousse des commits dessus qui impl√©mentent le changement

== !

image:gitmulti2.svg[]

== !

image:gitmulti3.svg[]

Quand le travail est fini, la branche de travail est "merg√©e" dans staging

== !

image:gitmulti4.svg[]

== Gestion des remotes

O√π vivent ces branches ?

== Plusieurs mod√®les possibles

* Un remote pour les gouverner tous !
* Chacun son propre remote (et les commits seront bien gard√©s)
* ... whatever floats your boat!

== Un remote pour les gouverner tous

Tous les d√©veloppeurs envoient leur commits et branches sur le m√™me remote

* Simple a g√©rer ...
* ... mais n√©cessite que tous les contributeurs aient acc√®s au d√©p√¥t
** Adapt√© a l'entreprise, peu adapt√© au monde de l'open source

== !

image:remotemulti1.svg[]

== Chacun son propre remote

* La motivation: le contr√¥le d'acc√®s
** Tout le monde peut lire le d√©p√¥t principal. Personne ne peut √©crire dessus.
** Tout le monde peut dupliquer le d√©p√¥t public et √©crire sur sa copie.
** Toute modification du d√©p√¥t principal passe par une proc√©dure de revue.
** Si la revue est valid√©e, alors la branche est "merg√©e" dans la branche cible

* C'est le mod√®le pouss√© par GitHub !

== !

image:remotemulti2.svg[]

== Forks ! Forks everywhere !

Dans la terminologie GitHub:

* Un fork est un remote copi√© d'un d√©p√¥t principal
** C'est la o√π les contributeurs poussent leur branche de travail.
* Les branches de version (main, staging...) vivent sur le d√©p√¥t principal
* La proc√©dure de ramener un changement d'un fork √† un d√©p√¥t principal s'appelle la Pull Request (PR)

== üéì Exercice: Cr√©ez un fork

* Nous allons vous faire forker vos d√©p√¥ts respectifs
* Trouvez vous un bin√¥me dans le groupe et √©changez vos URL de d√©p√¥ts
* Depuis la page du d√©p√¥t de votre bin√¥me, cliquez en haut √† droite sur le bouton **Fork**.

image:fork.png[]

[{invert}]
== !

üéì √Ä vous de jouer : dans le d√©p√¥t de votre bin√¥me, vous allez ajouter un √©tape de "lint"

== üéì Exercice: Contribuez au projet de votre bin√¥me (1/5)

Premi√®re √©tape: on clone le fork dans son environnement de d√©veloppement

[source,bash]
----
cd /workspace/

# Clonez votre fork
git clone <url_de_votre_fork>

# Se placer dans le fork
cd <nom_du_fork>

# Cr√©ez votre feature branch
git switch --create feat/hadolint
----

== üéì Exercice: Contribuez au projet de votre bin√¥me (2/5)

Maintenant voici la liste des choses √† faire:

* Ajoutez une √©tape de "lint" dans le workflow, avant de fabriquer l'image
** La ligne de commande https://github.com/hadolint/hadolint[`hadolint`] est pr√©-install√©e dans votre GitPod
** https://github.com/hadolint/hadolint-action[GitHub action hadolint]

* Corrigez /ignorez les erreurs du lint afin d'avoir un build qui passe

== üéì Exercice: Contribuez au projet de votre bin√¥me (3/5)

Pour tester votre changement :

[source, bash]
----
hadolint ./Dockerfile
----

== üéì Exercice: Contribuez au projet de votre bin√¥me (4/5)

Une fois que vous √™tes satisfaits de votre changement il vous faut maintenant cr√©er un commit et pousser votre nouvelle branche sur votre fork.

== üéì Exercice: Contribuez au projet de votre bin√¥me (5/5)

Derni√®re √©tape: ouvrir une pull request!

* Rendez vous sur la page de votre projet
* S√©lectionnez votre branche dans le menu d√©roulant "branches"  en haut a gauche.
* Cliquez ensuite sur le bouton ouvrir une pull request
* Remplissez le contenu de votre PR (titre, description, labels) et validez.

image:pr.png[]

== La proc√©dure de Pull Request

*Objectif* : Valider les changements d'un contributeur

* Technique : est-ce que √ßa marche ? est-ce maintenable ?
* Fonctionnel : est-ce que le code fait ce que l'on veux ?
* Humain : Propager la connaissance par la revue de code.
* M√©thode : Tracer les changements.

== Revue de code ?

* Validation par un ou plusieurs pairs (technique et non technique) des changements
* Relecture depuis github (ou depuis le poste du d√©veloppeur)
* Chaque relecteur √©met des commentaires // suggestions de changement
* Quand un relecteur est satisfait d'un changement, il l'approuve

== !

* La revue de code est un **exercice difficile** et **potentiellement frustrant** pour les deux parties.
** Comme sur Twitter, on est bien √† l'abri derri√®re son √©cran ;=)
* En tant que contributeur, **soyez respectueux** de vos relecteurs : votre changement peut √™tre refus√© et c'est quelque chose de normal.
* En tant que relecteur, **soyez respectueux** du travail effectu√©, m√™me si celui ci comporte des erreurs ou ne correspond pas √† vos attentes.

üí° Astuce: link:https://github.com/franckverrot/clamav-client/pull/12#discussion_r526222319[Proposez des solutions] plut√¥t que simplement pointer les probl√®mes.

== üéì Exercice: Relisez votre PR re√ßue !

* Vous devriez avoir re√ßu une PR de votre bin√¥me :-)
* Relisez le changement de la PR
* Effectuez quelques commentaires (bonus: utilisez la suggestion de changements), si c'est n√©cessaire
* Si elle vous convient, approuvez la!
* En revanche ne la "mergez" pas, car il manque quelque chose...

== Validation automatis√©e

**Objectif**: Valider que le changement n'introduit pas de r√©gressions dans le projet

* A chaque fois qu'un nouveau commit est cr√©√© dans une PR, une succession de validations ("checks") sont d√©clench√©s par GitHub
* Effectue des v√©rifications automatis√©es sur un commit de merge entre votre branche cible et la branche de PR

== Quelques exemples

* Analyse syntaxique du code (lint), pour d√©tecter les erreurs potentielles ou les violations du guide de style
* Compilation du projet
* Execution des tests automatis√©s du projet
* D√©ploiement du projet dans un environnement de test...

Ces "checks" peuvent √™tres ex√©cut√©s par votre moteur de CI ou des outils externes.

== üéì Exercice: D√©clencher un Workflow de CI sur une PR

* Votre PR n'a pas d√©clench√© le workflow de CI de votre bin√¥me ü§î
* Il faut modifier votre workflow pour qu'il se d√©clenche aussi sur une PR
* "Une chose √† la fois" : faites une PR d√©di√©e au d√©clenchement, puis mettez √† jour la PR initial
* La link:https://docs.github.com/en/actions/learn-github-actions/events-that-trigger-workflows[documentation] se trouve par ici

== Checkpoint üéØ

*R√®gle d'or*: Si le CI est rouge, on ne merge pas la pull request !

[.small]
M√™me si le linter "il√©con", m√™me si on a la flemme et "s√©panou" qui avons cass√© le CI.
